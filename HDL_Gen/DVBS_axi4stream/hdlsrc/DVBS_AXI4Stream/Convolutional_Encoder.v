// -------------------------------------------------------------
// 
// File Name: F:\Git_Repository\DVB-S\HDL_Gen\DVBS_axi4stream\hdlsrc\DVBS_AXI4Stream\Convolutional_Encoder.v
// Created: 2024-06-07 16:51:12
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Convolutional_Encoder
// Source Path: DVBS_AXI4Stream/DVB-S/Con_Encoder/Convolutional Encoder
// Hierarchy Level: 2
// Model version: 1.65
// 
// ConvolutionalEncoder
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ps

module Convolutional_Encoder
          (clk,
           reset_n,
           enb,
           in0,
           in1,
           out0_0,
           out0_1);


  input   clk;
  input   reset_n;
  input   enb;
  input   in0;
  input   in1;
  output  out0_0;  // boolean
  output  out0_1;  // boolean


  reg  enbSig_1;  // ufix1
  reg  datainReg_1;  // ufix1
  reg  bitinreg_1;  // ufix1
  reg  [5:0] shiftreg;  // ufix1 [6]
  wire [5:0] shiftreg_next;  // ufix1 [6]
  wire shiftreg_0;  // ufix1
  wire shiftreg_1_1;  // ufix1
  wire shiftreg_2;  // ufix1
  wire shiftreg_5;  // ufix1
  wire encoded_entry1;  // ufix1
  wire shiftreg_4;  // ufix1
  wire encoded_entry2;  // ufix1
  wire [1:0] encoded;  // ufix1 [2]
  reg  [1:0] dataOut;  // boolean [2]


  // register the validin signal
  always @(posedge clk or negedge reset_n)
    begin : enbSig_process
      if (reset_n == 1'b0) begin
        enbSig_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          enbSig_1 <= in1;
        end
      end
    end



  // register the datain signal
  always @(posedge clk or negedge reset_n)
    begin : datainreg_process
      if (reset_n == 1'b0) begin
        datainReg_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          datainReg_1 <= in0;
        end
      end
    end



  // delay the bitin signal
  always @(posedge clk or negedge reset_n)
    begin : bitinreg_process
      if (reset_n == 1'b0) begin
        bitinreg_1 <= 1'b0;
      end
      else begin
        if (enb && enbSig_1) begin
          bitinreg_1 <= datainReg_1;
        end
      end
    end



  assign shiftreg_next[0] = bitinreg_1;
  assign shiftreg_next[1] = shiftreg[0];
  assign shiftreg_next[2] = shiftreg[1];
  assign shiftreg_next[3] = shiftreg[2];
  assign shiftreg_next[4] = shiftreg[3];
  assign shiftreg_next[5] = shiftreg[4];

  // update shift registers
  always @(posedge clk or negedge reset_n)
    begin : shiftreg_1_process
      if (reset_n == 1'b0) begin
        shiftreg <= {6{1'b0}};
      end
      else begin
        if (enb && enbSig_1) begin
          shiftreg <= shiftreg_next;
        end
      end
    end



  assign shiftreg_0 = shiftreg[0];

  assign shiftreg_1_1 = shiftreg[1];

  assign shiftreg_2 = shiftreg[2];

  assign shiftreg_5 = shiftreg[5];

  assign encoded_entry1 = shiftreg_5 ^ (shiftreg_2 ^ (shiftreg_1_1 ^ (bitinreg_1 ^ shiftreg_0)));



  assign shiftreg_4 = shiftreg[4];

  // encoded output
  assign encoded_entry2 = shiftreg_5 ^ (shiftreg_4 ^ (shiftreg_2 ^ (bitinreg_1 ^ shiftreg_1_1)));



  assign encoded[0] = encoded_entry1;
  assign encoded[1] = encoded_entry2;

  // register output signal
  always @(posedge clk or negedge reset_n)
    begin : reg_rsvd_process
      if (reset_n == 1'b0) begin
        dataOut <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          dataOut <= encoded;
        end
      end
    end



  assign out0_0 = dataOut[0];

  assign out0_1 = dataOut[1];

endmodule  // Convolutional_Encoder

