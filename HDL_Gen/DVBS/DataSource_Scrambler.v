// -------------------------------------------------------------
// 
// File Name: F:\Git_Repository\DVB-S\HDL_Gen\DVBS\DataSource_Scrambler.v
// Created: 2024-06-09 10:16:43
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 5e-09
// Target subsystem base rate: 5e-09
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        5e-09
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// simStart                      ce_out        5e-09
// simEnd                        ce_out        5e-09
// simEN                         ce_out        5e-09
// ScramblerOut                  ce_out        5e-09
// BinEn                         ce_out        5e-09
// DataGenEn                     ce_out        5e-09
// TSout                         ce_out        5e-09
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: DataSource_Scrambler
// Source Path: DVBS/DataSource_Scrambler
// Hierarchy Level: 0
// Model version: 1.64
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module DataSource_Scrambler
          (clk,
           reset_n,
           clk_enable,
           ce_out,
           simStart,
           simEnd,
           simEN,
           ScramblerOut,
           BinEn,
           DataGenEn,
           TSout);


  input   clk;
  input   reset_n;
  input   clk_enable;
  output  ce_out;
  output  simStart;
  output  simEnd;
  output  simEN;
  output  [7:0] ScramblerOut;  // uint8
  output  BinEn;
  output  DataGenEn;
  output  [7:0] TSout;  // uint8


  wire enb;
  wire CLKdivide_out1;
  wire CLKdivide_out2;
  wire RS_Ctrl_out1;
  wire RS_Ctrl_out2;
  wire RS_Ctrl_out3;
  wire bit_sys_out1;
  wire bit_sys_out2;
  wire bit_sys_out3;
  reg  Delay_out1;
  reg  Delay1_out1;
  reg  Delay2_out1;
  wire HeaderProcess_out1;
  reg  Delay7_out1;
  wire [7:0] sigSource_out1;  // uint8
  wire HeaderProcess_out2;
  wire HeaderProcess_out3;
  wire [7:0] HeaderProcess_out4;  // uint8
  reg [7:0] Delay10_out1;  // uint8
  reg  HeaderProcess_out2_1;
  reg  Delay8_out1;
  reg  HeaderProcess_out3_1;
  reg  Delay9_out1;
  reg  CLKdivide_out1_1;
  wire [7:0] myScrambler_out1;  // uint8
  reg  Delay4_out1;
  reg  Delay4_out1_1;
  reg  Delay5_out1;
  reg  Delay5_out1_1;
  reg [7:0] Delay6_out1;  // uint8


  CLKdivide u_CLKdivide (.clk(clk),
                         .reset_n(reset_n),
                         .enb(clk_enable),
                         .DataGenEn(CLKdivide_out1),
                         .BinEn(CLKdivide_out2)
                         );

  RS_Ctrl u_RS_Ctrl (.clk(clk),
                     .reset_n(reset_n),
                     .enb(clk_enable),
                     .DataGenEn(CLKdivide_out1),
                     .simStart(RS_Ctrl_out1),
                     .simEnd(RS_Ctrl_out2),
                     .simEN(RS_Ctrl_out3)
                     );

  bit_sys u_bit_sys (.clk(clk),
                     .reset_n(reset_n),
                     .enb(clk_enable),
                     .simStart(RS_Ctrl_out1),
                     .simEnd(RS_Ctrl_out2),
                     .simEN(RS_Ctrl_out3),
                     .Enable(CLKdivide_out1),
                     .Out1(bit_sys_out1),
                     .Out2(bit_sys_out2),
                     .Out3(bit_sys_out3)
                     );

  assign enb = clk_enable;

  always @(posedge clk or negedge reset_n)
    begin : delayMatch3_process
      if (reset_n == 1'b0) begin
        Delay_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay_out1 <= bit_sys_out1;
        end
      end
    end



  assign simStart = Delay_out1;

  always @(posedge clk or negedge reset_n)
    begin : delayMatch4_process
      if (reset_n == 1'b0) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= bit_sys_out2;
        end
      end
    end



  assign simEnd = Delay1_out1;

  always @(posedge clk or negedge reset_n)
    begin : delayMatch5_process
      if (reset_n == 1'b0) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= bit_sys_out3;
        end
      end
    end



  assign simEN = Delay2_out1;

  always @(posedge clk or negedge reset_n)
    begin : Delay7_process
      if (reset_n == 1'b0) begin
        Delay7_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= HeaderProcess_out1;
        end
      end
    end



  sigSource u_sigSource (.clk(clk),
                         .reset_n(reset_n),
                         .enb(clk_enable),
                         .DataGenEn(CLKdivide_out1),
                         .Enable(Delay7_out1),
                         .simDataOut(sigSource_out1)  // uint8
                         );

  HeaderProcess u_HeaderProcess (.clk(clk),
                                 .reset_n(reset_n),
                                 .enb(clk_enable),
                                 .simDataIn(sigSource_out1),  // uint8
                                 .DataGenEn(CLKdivide_out1),
                                 .DataGenEN_1(HeaderProcess_out1),
                                 .ScrambleEn(HeaderProcess_out2),
                                 .ScrambleRst(HeaderProcess_out3),
                                 .ProcessDataOut(HeaderProcess_out4)  // uint8
                                 );

  always @(posedge clk or negedge reset_n)
    begin : Delay10_process
      if (reset_n == 1'b0) begin
        Delay10_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay10_out1 <= HeaderProcess_out4;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch_process
      if (reset_n == 1'b0) begin
        HeaderProcess_out2_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          HeaderProcess_out2_1 <= HeaderProcess_out2;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : Delay8_process
      if (reset_n == 1'b0) begin
        Delay8_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay8_out1 <= HeaderProcess_out2_1;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch1_process
      if (reset_n == 1'b0) begin
        HeaderProcess_out3_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          HeaderProcess_out3_1 <= HeaderProcess_out3;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : Delay9_process
      if (reset_n == 1'b0) begin
        Delay9_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1 <= HeaderProcess_out3_1;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch2_process
      if (reset_n == 1'b0) begin
        CLKdivide_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          CLKdivide_out1_1 <= CLKdivide_out1;
        end
      end
    end



  myScrambler u_myScrambler (.clk(clk),
                             .reset_n(reset_n),
                             .enb(clk_enable),
                             .DataIn(Delay10_out1),  // uint8
                             .EN(Delay8_out1),
                             .RST_IniState(Delay9_out1),
                             .Trigger(CLKdivide_out1_1),
                             .Out1(myScrambler_out1)  // uint8
                             );

  assign ScramblerOut = myScrambler_out1;

  always @(posedge clk or negedge reset_n)
    begin : Delay4_process
      if (reset_n == 1'b0) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= CLKdivide_out2;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch6_process
      if (reset_n == 1'b0) begin
        Delay4_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1_1 <= Delay4_out1;
        end
      end
    end



  assign BinEn = Delay4_out1_1;

  always @(posedge clk or negedge reset_n)
    begin : Delay5_process
      if (reset_n == 1'b0) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= CLKdivide_out1;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch7_process
      if (reset_n == 1'b0) begin
        Delay5_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1_1 <= Delay5_out1;
        end
      end
    end



  assign DataGenEn = Delay5_out1_1;

  always @(posedge clk or negedge reset_n)
    begin : Delay6_process
      if (reset_n == 1'b0) begin
        Delay6_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= HeaderProcess_out4;
        end
      end
    end



  assign TSout = Delay6_out1;

  assign ce_out = clk_enable;

endmodule  // DataSource_Scrambler

