// -------------------------------------------------------------
// 
// File Name: F:\Git_Repository\DVB-S\HDL_Gen\DVBS\DataSource_Scrambler.v
// Created: 2024-06-06 18:56:50
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 5e-09
// Target subsystem base rate: 5e-09
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        5e-09
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// simStart                      ce_out        5e-09
// simEnd                        ce_out        5e-09
// simEN                         ce_out        5e-09
// ScramblerOut                  ce_out        5e-09
// BinEn                         ce_out        5e-09
// DataGenEn                     ce_out        5e-09
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: DataSource_Scrambler
// Source Path: DVBS/DataSource_Scrambler
// Hierarchy Level: 0
// Model version: 1.63
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ps

module DataSource_Scrambler
          (clk,
           reset_n,
           clk_enable,
           ce_out,
           simStart,
           simEnd,
           simEN,
           ScramblerOut,
           BinEn,
           DataGenEn);


  input   clk;
  input   reset_n;
  input   clk_enable;
  output  ce_out;
  output  simStart;
  output  simEnd;
  output  simEN;
  output  [7:0] ScramblerOut;  // uint8
  output  BinEn;
  output  DataGenEn;


  wire enb;
  wire CLKdivide_out1;
  wire CLKdivide_out2;
  wire [7:0] sigSource_out4;  // uint8
  wire HeaderProcess_out1;
  wire HeaderProcess_out2;
  wire HeaderProcess_out3;
  wire [7:0] HeaderProcess_out4;  // uint8
  reg  Delay7_out1;
  wire sigSource_out1;
  wire sigSource_out2;
  wire sigSource_out3;
  wire Detect_Rise_Positive_out1;
  reg  Delay_out1;
  reg  Delay_out1_1;
  wire Detect_Rise_Positive1_out1;
  reg  [1:0] Delay1_reg;  // ufix1 [2]
  wire Delay1_out1;
  reg  Delay1_out1_1;
  reg  Delay2_out1;
  reg  Delay2_out1_1;
  reg [7:0] Delay10_out1;  // uint8
  reg  HeaderProcess_out2_1;
  reg  Delay8_out1;
  reg  HeaderProcess_out3_1;
  reg  Delay9_out1;
  reg  CLKdivide_out1_1;
  wire [7:0] myScrambler_out1;  // uint8
  reg [7:0] Delay3_out1;  // uint8
  reg  Delay4_out1;
  reg  [1:0] delayMatch3_reg;  // ufix1 [2]
  wire Delay4_out1_1;
  reg  Delay5_out1;
  reg  [1:0] delayMatch4_reg;  // ufix1 [2]
  wire Delay5_out1_1;


  CLKdivide u_CLKdivide (.clk(clk),
                         .reset_n(reset_n),
                         .enb(clk_enable),
                         .DataGenEn(CLKdivide_out1),
                         .BinEn(CLKdivide_out2)
                         );

  assign enb = clk_enable;

  HeaderProcess u_HeaderProcess (.clk(clk),
                                 .reset_n(reset_n),
                                 .enb(clk_enable),
                                 .simDataIn(sigSource_out4),  // uint8
                                 .DataGenEn(CLKdivide_out1),
                                 .DataGenEN_1(HeaderProcess_out1),
                                 .ScrambleEn(HeaderProcess_out2),
                                 .ScrambleRst(HeaderProcess_out3),
                                 .DataIn(HeaderProcess_out4)  // uint8
                                 );

  always @(posedge clk or negedge reset_n)
    begin : Delay7_process
      if (reset_n == 1'b0) begin
        Delay7_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= HeaderProcess_out1;
        end
      end
    end



  sigSource u_sigSource (.clk(clk),
                         .reset_n(reset_n),
                         .enb(clk_enable),
                         .DataGenEn(CLKdivide_out1),
                         .Enable(Delay7_out1),
                         .simStart(sigSource_out1),
                         .simEnd(sigSource_out2),
                         .simEN(sigSource_out3),
                         .simDataIn(sigSource_out4)  // uint8
                         );

  Detect_Rise_Positive_block u_Detect_Rise_Positive (.clk(clk),
                                                     .reset_n(reset_n),
                                                     .enb(clk_enable),
                                                     .U(sigSource_out1),
                                                     .Y(Detect_Rise_Positive_out1)
                                                     );

  always @(posedge clk or negedge reset_n)
    begin : Delay_process
      if (reset_n == 1'b0) begin
        Delay_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay_out1 <= Detect_Rise_Positive_out1;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : out_0_pipe_process
      if (reset_n == 1'b0) begin
        Delay_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay_out1_1 <= Delay_out1;
        end
      end
    end



  assign simStart = Delay_out1_1;

  Detect_Rise_Positive1 u_Detect_Rise_Positive1 (.clk(clk),
                                                 .reset_n(reset_n),
                                                 .enb(clk_enable),
                                                 .U(sigSource_out2),
                                                 .Y(Detect_Rise_Positive1_out1)
                                                 );

  always @(posedge clk or negedge reset_n)
    begin : Delay1_process
      if (reset_n == 1'b0) begin
        Delay1_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= Detect_Rise_Positive1_out1;
          Delay1_reg[1] <= Delay1_reg[0];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[1];



  always @(posedge clk or negedge reset_n)
    begin : out_1_pipe_process
      if (reset_n == 1'b0) begin
        Delay1_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1_1 <= Delay1_out1;
        end
      end
    end



  assign simEnd = Delay1_out1_1;

  always @(posedge clk or negedge reset_n)
    begin : Delay2_process
      if (reset_n == 1'b0) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= sigSource_out3;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : out_2_pipe_process
      if (reset_n == 1'b0) begin
        Delay2_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1_1 <= Delay2_out1;
        end
      end
    end



  assign simEN = Delay2_out1_1;

  always @(posedge clk or negedge reset_n)
    begin : Delay10_process
      if (reset_n == 1'b0) begin
        Delay10_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay10_out1 <= HeaderProcess_out4;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch_process
      if (reset_n == 1'b0) begin
        HeaderProcess_out2_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          HeaderProcess_out2_1 <= HeaderProcess_out2;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : Delay8_process
      if (reset_n == 1'b0) begin
        Delay8_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay8_out1 <= HeaderProcess_out2_1;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch1_process
      if (reset_n == 1'b0) begin
        HeaderProcess_out3_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          HeaderProcess_out3_1 <= HeaderProcess_out3;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : Delay9_process
      if (reset_n == 1'b0) begin
        Delay9_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1 <= HeaderProcess_out3_1;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch2_process
      if (reset_n == 1'b0) begin
        CLKdivide_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          CLKdivide_out1_1 <= CLKdivide_out1;
        end
      end
    end



  myScrambler u_myScrambler (.clk(clk),
                             .reset_n(reset_n),
                             .enb(clk_enable),
                             .DataIn(Delay10_out1),  // uint8
                             .EN(Delay8_out1),
                             .RST_IniState(Delay9_out1),
                             .Trigger(CLKdivide_out1_1),
                             .Out1(myScrambler_out1)  // uint8
                             );

  always @(posedge clk or negedge reset_n)
    begin : out_3_pipe_process
      if (reset_n == 1'b0) begin
        Delay3_out1 <= 8'b00000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= myScrambler_out1;
        end
      end
    end



  assign ScramblerOut = Delay3_out1;

  always @(posedge clk or negedge reset_n)
    begin : Delay4_process
      if (reset_n == 1'b0) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= CLKdivide_out2;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch3_process
      if (reset_n == 1'b0) begin
        delayMatch3_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch3_reg[0] <= Delay4_out1;
          delayMatch3_reg[1] <= delayMatch3_reg[0];
        end
      end
    end

  assign Delay4_out1_1 = delayMatch3_reg[1];



  assign BinEn = Delay4_out1_1;

  always @(posedge clk or negedge reset_n)
    begin : Delay5_process
      if (reset_n == 1'b0) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= CLKdivide_out1;
        end
      end
    end



  always @(posedge clk or negedge reset_n)
    begin : delayMatch4_process
      if (reset_n == 1'b0) begin
        delayMatch4_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch4_reg[0] <= Delay5_out1;
          delayMatch4_reg[1] <= delayMatch4_reg[0];
        end
      end
    end

  assign Delay5_out1_1 = delayMatch4_reg[1];



  assign DataGenEn = Delay5_out1_1;

  assign ce_out = clk_enable;

endmodule  // DataSource_Scrambler

