// -------------------------------------------------------------
// 
// File Name: F:\Git_Repository\DVB-S\HDL_Gen\DVBS\Convolutional_Interleaver.v
// Created: 2024-06-06 15:05:16
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Convolutional_Interleaver
// Source Path: DVBS/Interleaver/Con_Interleaver/Convolutional Interleaver
// Hierarchy Level: 2
// Model version: 1.63
// 
// Convolutional Interleaver - Shift Register Implementation
// N (rows) = 12, B (register length step) = 17
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ps

module Convolutional_Interleaver
          (clk,
           reset_n,
           enb,
           In1,
           Convolutional_Interleaver_out1);


  input   clk;
  input   reset_n;
  input   enb;
  input   [7:0] In1;  // uint8
  output  [7:0] Convolutional_Interleaver_out1;  // uint8


  reg [3:0] branch_val;  // ufix4
  wire is_branch_1;
  reg [7:0] branch_1_reg [0:16];  // ufix8 [17]
  reg [7:0] branch_1_reg_next [0:16];  // ufix8 [17]
  reg [7:0] op_branch_1;  // uint8
  wire is_branch_2;
  reg [7:0] branch_2_reg [0:33];  // ufix8 [34]
  reg [7:0] branch_2_reg_next [0:33];  // ufix8 [34]
  reg [7:0] op_branch_2;  // uint8
  wire is_branch_3;
  reg [7:0] branch_3_reg [0:50];  // ufix8 [51]
  reg [7:0] branch_3_reg_next [0:50];  // ufix8 [51]
  reg [7:0] op_branch_3;  // uint8
  wire is_branch_4;
  reg [7:0] branch_4_reg [0:67];  // ufix8 [68]
  reg [7:0] branch_4_reg_next [0:67];  // ufix8 [68]
  reg [7:0] op_branch_4;  // uint8
  wire is_branch_5;
  reg [7:0] branch_5_reg [0:84];  // ufix8 [85]
  reg [7:0] branch_5_reg_next [0:84];  // ufix8 [85]
  reg [7:0] op_branch_5;  // uint8
  wire is_branch_6;
  reg [7:0] branch_6_reg [0:101];  // ufix8 [102]
  reg [7:0] branch_6_reg_next [0:101];  // ufix8 [102]
  reg [7:0] op_branch_6;  // uint8
  wire is_branch_7;
  reg [7:0] branch_7_reg [0:118];  // ufix8 [119]
  reg [7:0] branch_7_reg_next [0:118];  // ufix8 [119]
  reg [7:0] op_branch_7;  // uint8
  wire is_branch_8;
  reg [7:0] branch_8_reg [0:135];  // ufix8 [136]
  reg [7:0] branch_8_reg_next [0:135];  // ufix8 [136]
  reg [7:0] op_branch_8;  // uint8
  wire is_branch_9;
  reg [7:0] branch_9_reg [0:152];  // ufix8 [153]
  reg [7:0] branch_9_reg_next [0:152];  // ufix8 [153]
  reg [7:0] op_branch_9;  // uint8
  wire is_branch_10;
  reg [7:0] branch_10_reg [0:169];  // ufix8 [170]
  reg [7:0] branch_10_reg_next [0:169];  // ufix8 [170]
  reg [7:0] op_branch_10;  // uint8
  wire is_branch_11;
  reg [7:0] branch_11_reg [0:186];  // ufix8 [187]
  reg [7:0] branch_11_reg_next [0:186];  // ufix8 [187]
  reg [7:0] op_branch_11;  // uint8
  reg signed [31:0] branch_1_t_0_0;  // int32
  reg signed [31:0] branch_1_t_0_1;  // int32
  reg signed [31:0] branch_1_t_1;  // int32
  reg signed [31:0] branch_2_t_0_0;  // int32
  reg signed [31:0] branch_2_t_0_1;  // int32
  reg signed [31:0] branch_2_t_1;  // int32
  reg signed [31:0] branch_3_t_0_0;  // int32
  reg signed [31:0] branch_3_t_0_1;  // int32
  reg signed [31:0] branch_3_t_1;  // int32
  reg signed [31:0] branch_4_t_0_0;  // int32
  reg signed [31:0] branch_4_t_0_1;  // int32
  reg signed [31:0] branch_4_t_1;  // int32
  reg signed [31:0] branch_5_t_0_0;  // int32
  reg signed [31:0] branch_5_t_0_1;  // int32
  reg signed [31:0] branch_5_t_1;  // int32
  reg signed [31:0] branch_6_t_0_0;  // int32
  reg signed [31:0] branch_6_t_0_1;  // int32
  reg signed [31:0] branch_6_t_1;  // int32
  reg signed [31:0] branch_7_t_0_0;  // int32
  reg signed [31:0] branch_7_t_0_1;  // int32
  reg signed [31:0] branch_7_t_1;  // int32
  reg signed [31:0] branch_8_t_0_0;  // int32
  reg signed [31:0] branch_8_t_0_1;  // int32
  reg signed [31:0] branch_8_t_1;  // int32
  reg signed [31:0] branch_9_t_0_0;  // int32
  reg signed [31:0] branch_9_t_0_1;  // int32
  reg signed [31:0] branch_9_t_1;  // int32
  reg signed [31:0] branch_10_t_0_0;  // int32
  reg signed [31:0] branch_10_t_0_1;  // int32
  reg signed [31:0] branch_10_t_1;  // int32
  reg signed [31:0] branch_11_t_0_0;  // int32
  reg signed [31:0] branch_11_t_0_1;  // int32
  reg signed [31:0] branch_11_t_1;  // int32


  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 11
  // Counter for calculation of the commutator branch
  always @(posedge clk or negedge reset_n)
    begin : branch_process
      if (reset_n == 1'b0) begin
        branch_val <= 4'b0000;
      end
      else begin
        if (enb) begin
          if (branch_val >= 4'b1011) begin
            branch_val <= 4'b0000;
          end
          else begin
            branch_val <= branch_val + 4'b0001;
          end
        end
      end
    end



  // Enable for branch 1
  assign is_branch_1 = branch_val == 4'b0001;



  // Branch 1: Delay = 17
  always @(posedge clk or negedge reset_n)
    begin : branch_1_process
      if (reset_n == 1'b0) begin
        for(branch_1_t_1 = 32'sd0; branch_1_t_1 <= 32'sd16; branch_1_t_1 = branch_1_t_1 + 32'sd1) begin
          branch_1_reg[branch_1_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_1) begin
          for(branch_1_t_0_1 = 32'sd0; branch_1_t_0_1 <= 32'sd16; branch_1_t_0_1 = branch_1_t_0_1 + 32'sd1) begin
            branch_1_reg[branch_1_t_0_1] <= branch_1_reg_next[branch_1_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_1 = branch_1_reg[16];
    branch_1_reg_next[0] = In1;

    for(branch_1_t_0_0 = 32'sd0; branch_1_t_0_0 <= 32'sd15; branch_1_t_0_0 = branch_1_t_0_0 + 32'sd1) begin
      branch_1_reg_next[branch_1_t_0_0 + 32'sd1] = branch_1_reg[branch_1_t_0_0];
    end

  end



  // Enable for branch 2
  assign is_branch_2 = branch_val == 4'b0010;



  // Branch 2: Delay = 34
  always @(posedge clk or negedge reset_n)
    begin : branch_2_process
      if (reset_n == 1'b0) begin
        for(branch_2_t_1 = 32'sd0; branch_2_t_1 <= 32'sd33; branch_2_t_1 = branch_2_t_1 + 32'sd1) begin
          branch_2_reg[branch_2_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_2) begin
          for(branch_2_t_0_1 = 32'sd0; branch_2_t_0_1 <= 32'sd33; branch_2_t_0_1 = branch_2_t_0_1 + 32'sd1) begin
            branch_2_reg[branch_2_t_0_1] <= branch_2_reg_next[branch_2_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_2 = branch_2_reg[33];
    branch_2_reg_next[0] = In1;

    for(branch_2_t_0_0 = 32'sd0; branch_2_t_0_0 <= 32'sd32; branch_2_t_0_0 = branch_2_t_0_0 + 32'sd1) begin
      branch_2_reg_next[branch_2_t_0_0 + 32'sd1] = branch_2_reg[branch_2_t_0_0];
    end

  end



  // Enable for branch 3
  assign is_branch_3 = branch_val == 4'b0011;



  // Branch 3: Delay = 51
  always @(posedge clk or negedge reset_n)
    begin : branch_3_process
      if (reset_n == 1'b0) begin
        for(branch_3_t_1 = 32'sd0; branch_3_t_1 <= 32'sd50; branch_3_t_1 = branch_3_t_1 + 32'sd1) begin
          branch_3_reg[branch_3_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_3) begin
          for(branch_3_t_0_1 = 32'sd0; branch_3_t_0_1 <= 32'sd50; branch_3_t_0_1 = branch_3_t_0_1 + 32'sd1) begin
            branch_3_reg[branch_3_t_0_1] <= branch_3_reg_next[branch_3_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_3 = branch_3_reg[50];
    branch_3_reg_next[0] = In1;

    for(branch_3_t_0_0 = 32'sd0; branch_3_t_0_0 <= 32'sd49; branch_3_t_0_0 = branch_3_t_0_0 + 32'sd1) begin
      branch_3_reg_next[branch_3_t_0_0 + 32'sd1] = branch_3_reg[branch_3_t_0_0];
    end

  end



  // Enable for branch 4
  assign is_branch_4 = branch_val == 4'b0100;



  // Branch 4: Delay = 68
  always @(posedge clk or negedge reset_n)
    begin : branch_4_process
      if (reset_n == 1'b0) begin
        for(branch_4_t_1 = 32'sd0; branch_4_t_1 <= 32'sd67; branch_4_t_1 = branch_4_t_1 + 32'sd1) begin
          branch_4_reg[branch_4_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_4) begin
          for(branch_4_t_0_1 = 32'sd0; branch_4_t_0_1 <= 32'sd67; branch_4_t_0_1 = branch_4_t_0_1 + 32'sd1) begin
            branch_4_reg[branch_4_t_0_1] <= branch_4_reg_next[branch_4_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_4 = branch_4_reg[67];
    branch_4_reg_next[0] = In1;

    for(branch_4_t_0_0 = 32'sd0; branch_4_t_0_0 <= 32'sd66; branch_4_t_0_0 = branch_4_t_0_0 + 32'sd1) begin
      branch_4_reg_next[branch_4_t_0_0 + 32'sd1] = branch_4_reg[branch_4_t_0_0];
    end

  end



  // Enable for branch 5
  assign is_branch_5 = branch_val == 4'b0101;



  // Branch 5: Delay = 85
  always @(posedge clk or negedge reset_n)
    begin : branch_5_process
      if (reset_n == 1'b0) begin
        for(branch_5_t_1 = 32'sd0; branch_5_t_1 <= 32'sd84; branch_5_t_1 = branch_5_t_1 + 32'sd1) begin
          branch_5_reg[branch_5_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_5) begin
          for(branch_5_t_0_1 = 32'sd0; branch_5_t_0_1 <= 32'sd84; branch_5_t_0_1 = branch_5_t_0_1 + 32'sd1) begin
            branch_5_reg[branch_5_t_0_1] <= branch_5_reg_next[branch_5_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_5 = branch_5_reg[84];
    branch_5_reg_next[0] = In1;

    for(branch_5_t_0_0 = 32'sd0; branch_5_t_0_0 <= 32'sd83; branch_5_t_0_0 = branch_5_t_0_0 + 32'sd1) begin
      branch_5_reg_next[branch_5_t_0_0 + 32'sd1] = branch_5_reg[branch_5_t_0_0];
    end

  end



  // Enable for branch 6
  assign is_branch_6 = branch_val == 4'b0110;



  // Branch 6: Delay = 102
  always @(posedge clk or negedge reset_n)
    begin : branch_6_process
      if (reset_n == 1'b0) begin
        for(branch_6_t_1 = 32'sd0; branch_6_t_1 <= 32'sd101; branch_6_t_1 = branch_6_t_1 + 32'sd1) begin
          branch_6_reg[branch_6_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_6) begin
          for(branch_6_t_0_1 = 32'sd0; branch_6_t_0_1 <= 32'sd101; branch_6_t_0_1 = branch_6_t_0_1 + 32'sd1) begin
            branch_6_reg[branch_6_t_0_1] <= branch_6_reg_next[branch_6_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_6 = branch_6_reg[101];
    branch_6_reg_next[0] = In1;

    for(branch_6_t_0_0 = 32'sd0; branch_6_t_0_0 <= 32'sd100; branch_6_t_0_0 = branch_6_t_0_0 + 32'sd1) begin
      branch_6_reg_next[branch_6_t_0_0 + 32'sd1] = branch_6_reg[branch_6_t_0_0];
    end

  end



  // Enable for branch 7
  assign is_branch_7 = branch_val == 4'b0111;



  // Branch 7: Delay = 119
  always @(posedge clk or negedge reset_n)
    begin : branch_7_process
      if (reset_n == 1'b0) begin
        for(branch_7_t_1 = 32'sd0; branch_7_t_1 <= 32'sd118; branch_7_t_1 = branch_7_t_1 + 32'sd1) begin
          branch_7_reg[branch_7_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_7) begin
          for(branch_7_t_0_1 = 32'sd0; branch_7_t_0_1 <= 32'sd118; branch_7_t_0_1 = branch_7_t_0_1 + 32'sd1) begin
            branch_7_reg[branch_7_t_0_1] <= branch_7_reg_next[branch_7_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_7 = branch_7_reg[118];
    branch_7_reg_next[0] = In1;

    for(branch_7_t_0_0 = 32'sd0; branch_7_t_0_0 <= 32'sd117; branch_7_t_0_0 = branch_7_t_0_0 + 32'sd1) begin
      branch_7_reg_next[branch_7_t_0_0 + 32'sd1] = branch_7_reg[branch_7_t_0_0];
    end

  end



  // Enable for branch 8
  assign is_branch_8 = branch_val == 4'b1000;



  // Branch 8: Delay = 136
  always @(posedge clk or negedge reset_n)
    begin : branch_8_process
      if (reset_n == 1'b0) begin
        for(branch_8_t_1 = 32'sd0; branch_8_t_1 <= 32'sd135; branch_8_t_1 = branch_8_t_1 + 32'sd1) begin
          branch_8_reg[branch_8_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_8) begin
          for(branch_8_t_0_1 = 32'sd0; branch_8_t_0_1 <= 32'sd135; branch_8_t_0_1 = branch_8_t_0_1 + 32'sd1) begin
            branch_8_reg[branch_8_t_0_1] <= branch_8_reg_next[branch_8_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_8 = branch_8_reg[135];
    branch_8_reg_next[0] = In1;

    for(branch_8_t_0_0 = 32'sd0; branch_8_t_0_0 <= 32'sd134; branch_8_t_0_0 = branch_8_t_0_0 + 32'sd1) begin
      branch_8_reg_next[branch_8_t_0_0 + 32'sd1] = branch_8_reg[branch_8_t_0_0];
    end

  end



  // Enable for branch 9
  assign is_branch_9 = branch_val == 4'b1001;



  // Branch 9: Delay = 153
  always @(posedge clk or negedge reset_n)
    begin : branch_9_process
      if (reset_n == 1'b0) begin
        for(branch_9_t_1 = 32'sd0; branch_9_t_1 <= 32'sd152; branch_9_t_1 = branch_9_t_1 + 32'sd1) begin
          branch_9_reg[branch_9_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_9) begin
          for(branch_9_t_0_1 = 32'sd0; branch_9_t_0_1 <= 32'sd152; branch_9_t_0_1 = branch_9_t_0_1 + 32'sd1) begin
            branch_9_reg[branch_9_t_0_1] <= branch_9_reg_next[branch_9_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_9 = branch_9_reg[152];
    branch_9_reg_next[0] = In1;

    for(branch_9_t_0_0 = 32'sd0; branch_9_t_0_0 <= 32'sd151; branch_9_t_0_0 = branch_9_t_0_0 + 32'sd1) begin
      branch_9_reg_next[branch_9_t_0_0 + 32'sd1] = branch_9_reg[branch_9_t_0_0];
    end

  end



  // Enable for branch 10
  assign is_branch_10 = branch_val == 4'b1010;



  // Branch 10: Delay = 170
  always @(posedge clk or negedge reset_n)
    begin : branch_10_process
      if (reset_n == 1'b0) begin
        for(branch_10_t_1 = 32'sd0; branch_10_t_1 <= 32'sd169; branch_10_t_1 = branch_10_t_1 + 32'sd1) begin
          branch_10_reg[branch_10_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_10) begin
          for(branch_10_t_0_1 = 32'sd0; branch_10_t_0_1 <= 32'sd169; branch_10_t_0_1 = branch_10_t_0_1 + 32'sd1) begin
            branch_10_reg[branch_10_t_0_1] <= branch_10_reg_next[branch_10_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_10 = branch_10_reg[169];
    branch_10_reg_next[0] = In1;

    for(branch_10_t_0_0 = 32'sd0; branch_10_t_0_0 <= 32'sd168; branch_10_t_0_0 = branch_10_t_0_0 + 32'sd1) begin
      branch_10_reg_next[branch_10_t_0_0 + 32'sd1] = branch_10_reg[branch_10_t_0_0];
    end

  end



  // Enable for branch 11
  assign is_branch_11 = branch_val == 4'b1011;



  // Branch 11: Delay = 187
  always @(posedge clk or negedge reset_n)
    begin : branch_11_process
      if (reset_n == 1'b0) begin
        for(branch_11_t_1 = 32'sd0; branch_11_t_1 <= 32'sd186; branch_11_t_1 = branch_11_t_1 + 32'sd1) begin
          branch_11_reg[branch_11_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb && is_branch_11) begin
          for(branch_11_t_0_1 = 32'sd0; branch_11_t_0_1 <= 32'sd186; branch_11_t_0_1 = branch_11_t_0_1 + 32'sd1) begin
            branch_11_reg[branch_11_t_0_1] <= branch_11_reg_next[branch_11_t_0_1];
          end
        end
      end
    end

  always @* begin
    op_branch_11 = branch_11_reg[186];
    branch_11_reg_next[0] = In1;

    for(branch_11_t_0_0 = 32'sd0; branch_11_t_0_0 <= 32'sd185; branch_11_t_0_0 = branch_11_t_0_0 + 32'sd1) begin
      branch_11_reg_next[branch_11_t_0_0 + 32'sd1] = branch_11_reg[branch_11_t_0_0];
    end

  end



  // Pick the appropriate output based on the branch count
  // Branch 0: Delay = 0
  assign Convolutional_Interleaver_out1 = (branch_val == 4'b0000 ? In1 :
              (branch_val == 4'b0001 ? op_branch_1 :
              (branch_val == 4'b0010 ? op_branch_2 :
              (branch_val == 4'b0011 ? op_branch_3 :
              (branch_val == 4'b0100 ? op_branch_4 :
              (branch_val == 4'b0101 ? op_branch_5 :
              (branch_val == 4'b0110 ? op_branch_6 :
              (branch_val == 4'b0111 ? op_branch_7 :
              (branch_val == 4'b1000 ? op_branch_8 :
              (branch_val == 4'b1001 ? op_branch_9 :
              (branch_val == 4'b1010 ? op_branch_10 :
              op_branch_11)))))))))));



endmodule  // Convolutional_Interleaver

